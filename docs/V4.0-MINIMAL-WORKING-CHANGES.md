# V4.0 Minimal Working Changes - Get Atomic Swap Working

## Executive Summary
These are the **absolute minimum changes** required to have a working atomic swap that's near-1inch compatible. We skip partial fills, complex fee structures, and access control changes - focusing only on what's broken.

## The 5 Critical Fixes

### 1. Factory Deployment Fix (HIGHEST PRIORITY)
**File**: `contracts/SimplifiedEscrowFactory.sol`  
**Problem**: FACTORY immutable in escrows captures CREATE3 factory address, not our factory address  
**Impact**: All escrow operations fail with `InvalidImmutables()`

**Solution**: Deploy implementations in constructor (v2.3 pattern)
```solidity
// NEW: contracts/SimplifiedEscrowFactoryV4.sol
contract SimplifiedEscrowFactoryV4 is SimpleSettlement {
    constructor(
        address limitOrderProtocol,
        IERC20 accessToken,
        address owner,
        uint32 rescueDelay
    ) SimpleSettlement(limitOrderProtocol, accessToken, address(0), owner) {
        // Deploy implementations HERE so FACTORY = msg.sender works correctly
        ESCROW_SRC_IMPLEMENTATION = address(new EscrowSrc(rescueDelay, accessToken));
        ESCROW_DST_IMPLEMENTATION = address(new EscrowDst(rescueDelay, accessToken));
        _PROXY_SRC_BYTECODE_HASH = ProxyHashLib.computeProxyBytecodeHash(ESCROW_SRC_IMPLEMENTATION);
        _PROXY_DST_BYTECODE_HASH = ProxyHashLib.computeProxyBytecodeHash(ESCROW_DST_IMPLEMENTATION);
    }
}
```

### 2. Fix Timelock Packing (CRITICAL)
**File**: `contracts/SimplifiedEscrowFactory.sol:245-255`  
**Problem**: Incorrectly setting deployedAt in timelocks causes `InvalidTime()` errors  
**Impact**: All E2E tests fail, no operations work

**Current BROKEN Code**:
```solidity
// Lines 245-255 are ALL WRONG
uint256 packedTimelocks = uint256(uint32(block.timestamp)) << 224; // deployedAt
packedTimelocks |= uint256(uint32(0)) << 0; // srcWithdrawal
// ... more manual packing ...
```

**Fix**:
```solidity
// REMOVE all manual packing (lines 245-255)
// REPLACE with:
Timelocks memory timelocks = Timelocks({
    srcWithdrawal: 0,        // ⚠️ 0 for testing, USE 300 (5 min) for production!
    srcPublicWithdrawal: 60,
    srcCancellation: uint32(srcCancellationTimestamp - block.timestamp),
    srcPublicCancellation: uint32(srcCancellationTimestamp - block.timestamp + 60),
    dstWithdrawal: uint32(dstWithdrawalTimestamp - block.timestamp),
    dstPublicWithdrawal: uint32(dstWithdrawalTimestamp - block.timestamp + 60),
    dstCancellation: uint32(srcCancellationTimestamp - block.timestamp),
    deployedAt: 0  // Will be set by setDeployedAt
});

// Then use the library function:
immutables.timelocks = timelocks.pack().setDeployedAt(block.timestamp);

// NOTE: srcWithdrawal acts as timestamp tolerance/"finality period"
// - 0 seconds = immediate withdrawal (testing only)
// - 300 seconds = 5-minute buffer for chain timestamp drift (production)
```

### 3. Inherit from SimpleSettlement
**File**: `contracts/SimplifiedEscrowFactory.sol:20`  
**Problem**: Not inheriting from 1inch base contracts  
**Impact**: Can't integrate with 1inch limit order protocol

**Change**:
```solidity
// Line 20
contract SimplifiedEscrowFactory is SimpleSettlement {
    // Constructor must call SimpleSettlement
    constructor(
        address limitOrderProtocol,
        IERC20 accessToken, 
        address owner,
        uint32 rescueDelay
    ) SimpleSettlement(limitOrderProtocol, accessToken, address(0), owner) {
        // ... implementation deployment ...
    }
```

### 4. Make postInteraction Internal
**File**: `contracts/SimplifiedEscrowFactory.sol:205`  
**Problem**: Should be internal override, not external  
**Impact**: Breaks 1inch protocol flow

**Change**:
```solidity
// Change line 205 from:
function postInteraction(...) external override whenNotPaused {

// To:
function _postInteraction(...) internal override {
    // Remove whenNotPaused - SimpleSettlement handles this
    // Rest of implementation stays mostly the same
}
```

### 5. Add Minimal Parameters Structure
**File**: `contracts/SimplifiedEscrowFactory.sol:268,278`  
**Problem**: Empty parameters field breaks 1inch compatibility  
**Impact**: Destination escrow can't parse parameters

**Change**:
```solidity
// Line 268 - Source immutables
parameters: ""  // Keep empty for source (only dst uses it)

// Line 278 - Destination complement  
// Change from:
parameters: ""

// To:
parameters: abi.encode(
    uint256(0),  // protocolFeeAmount - we use 0
    uint256(0),  // integratorFeeAmount - we use 0
    Address.wrap(0),  // protocolFeeRecipient - not used
    Address.wrap(0)   // integratorFeeRecipient - not used
)
```

## What We're NOT Changing (Yet)

1. **Partial Fill Support** - Skip MerkleStorageInvalidator for now
2. **Complex Fee Calculations** - Use zero fees but keep structure
3. **Access Token System** - Keep our whitelist approach
4. **ExtraData Chaining** - Not needed for basic functionality
5. ~~**Timestamp Tolerance**~~ - ✅ Already implemented via srcWithdrawal offset!

## Implementation Steps

### Step 1: Create New Factory Contract
Create `contracts/SimplifiedEscrowFactoryV4.sol` with all fixes:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import { SimpleSettlement } from "limit-order-settlement/contracts/SimpleSettlement.sol";
import { IERC20 } from "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import { EscrowSrc } from "./EscrowSrc.sol";
import { EscrowDst } from "./EscrowDst.sol";
import { ProxyHashLib } from "./libraries/ProxyHashLib.sol";
// ... other imports ...

contract SimplifiedEscrowFactoryV4 is SimpleSettlement {
    address public immutable ESCROW_SRC_IMPLEMENTATION;
    address public immutable ESCROW_DST_IMPLEMENTATION;
    bytes32 internal immutable _PROXY_SRC_BYTECODE_HASH;
    bytes32 internal immutable _PROXY_DST_BYTECODE_HASH;
    
    constructor(
        address limitOrderProtocol,
        IERC20 accessToken,
        address owner,
        uint32 rescueDelay
    ) SimpleSettlement(limitOrderProtocol, accessToken, address(0), owner) {
        // Deploy implementations in constructor so FACTORY is correct
        ESCROW_SRC_IMPLEMENTATION = address(new EscrowSrc(rescueDelay, accessToken));
        ESCROW_DST_IMPLEMENTATION = address(new EscrowDst(rescueDelay, accessToken));
        _PROXY_SRC_BYTECODE_HASH = ProxyHashLib.computeProxyBytecodeHash(ESCROW_SRC_IMPLEMENTATION);
        _PROXY_DST_BYTECODE_HASH = ProxyHashLib.computeProxyBytecodeHash(ESCROW_DST_IMPLEMENTATION);
    }
    
    function _postInteraction(
        IOrderMixin.Order calldata order,
        bytes calldata extension,
        bytes32 orderHash,
        address taker,
        uint256 makingAmount,
        uint256 takingAmount,
        uint256 remainingMakingAmount,
        bytes calldata extraData
    ) internal override {
        // Implementation with fixed timelock packing
    }
}
```

### Step 2: Fix Tests
Update test files to use new factory and expect correct behavior:
```solidity
// test/E2E_SingleChain.t.sol
// Remove manual timelock packing
// Use library functions properly
```

### Step 3: Deploy Script
Update deployment to use V4:
```solidity
// script/Deploy.s.sol
SimplifiedEscrowFactoryV4 factory = new SimplifiedEscrowFactoryV4(
    limitOrderProtocol,
    accessToken,
    owner,
    rescueDelay
);
```

## Testing Checklist

After implementing these changes:

1. [ ] Factory deploys implementations in constructor
2. [ ] FACTORY immutable in escrows points to our factory (not CREATE3)
3. [ ] Timelocks use setDeployedAt() properly
4. [ ] E2E tests pass without InvalidTime() errors
5. [ ] Can create source escrow via _postInteraction
6. [ ] Can create destination escrow
7. [ ] Can withdraw with valid secret
8. [ ] Can cancel after timeout

## Expected Results

With these minimal changes:
- ✅ Atomic swaps will work
- ✅ Near-1inch compatible (can add full compatibility later)
- ✅ All tests pass
- ✅ Ready for testnet deployment
- ✅ Can integrate with 1inch limit order protocol (basic level)

## Not Expected (Deferred)

- ❌ Partial fills (need MerkleStorageInvalidator)
- ❌ Fee collection (using zero fees)
- ❌ Complex access control (keeping simple whitelist)
- ❌ Full event compatibility (can update later)

## Summary

These 5 changes are the **absolute minimum** to get from broken to working while maintaining a path to full 1inch compatibility. The key insight is that we must:

1. Fix the critical deployment bug (factory address)
2. Fix the timelock packing bug (causing test failures)
3. Inherit from SimpleSettlement (for 1inch integration)
4. Use internal _postInteraction (required pattern)
5. Have valid parameters structure (even if zero fees)

With these changes, we'll have a working atomic swap that can later be enhanced with partial fills, fees, and other advanced features as needed.